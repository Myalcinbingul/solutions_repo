{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is a fundamental topic in physics that provides insight into motion under the influence of gravity. By analyzing how the range of a projectile depends on its angle of projection, we can explore the underlying principles of kinematics and dynamics. The motion is governed by a set of equations involving parameters such as: - Initial velocity ( \\(v_0\\) ) - Acceleration due to gravity ( \\(g\\) ) - Launch height ( \\(h\\) ) - Launch angle ( \\(\\theta\\) ) These parameters influence the motion in both the horizontal and vertical directions, leading to a wide range of applications, from sports to aerospace engineering. 1. Theoretical Foundation Equations of Motion The motion of a projectile can be analyzed by splitting it into horizontal and vertical components. 1.1 Kinematic Equations Horizontal motion (constant velocity): $$ x = v_0 \\cos(\\theta) t $$ Vertical motion (under acceleration due to gravity): $$ y = h + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ 1.2 Time of Flight The time it takes for the projectile to hit the ground ( \\(y=0\\) ) is found by solving: \\[ h + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 = 0 \\] Solving this quadratic equation for \\(t\\) , we get: \\[ t = \\frac{v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g h}}{g} \\] 1.3 Range of the Projectile The range \\(R\\) is the horizontal distance covered by the projectile: \\[ R = v_0 \\cos(\\theta) \\times t \\] Substituting \\(t\\) from the time of flight equation: \\[ R = \\frac{v_0 \\cos(\\theta) \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g h} \\right)}{g} \\] For a projectile launched from ground level ( \\(h=0\\) ), the formula simplifies to: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2. Analysis of the Range 2.1 Dependence on Launch Angle The range is maximum when \\(\\theta = 45^\\circ\\) in the ideal case ( \\(h=0\\) ). For nonzero initial height, the maximum angle may shift slightly. 2.2 Effect of Other Parameters Increasing \\(v_0\\) increases the range quadratically. Higher launch heights generally increase the range. Increasing \\(g\\) (e.g., on different planets) decreases the range. 3. Practical Applications Sports : Optimizing the angle for maximum distance in long jump, basketball shots, etc. Engineering : Designing artillery, rocket launch trajectories. Astrophysics : Studying trajectories of objects on planetary surfaces. 4. Implementation in Python import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, h=0, g=9.81): theta_rad = np.deg2rad(theta) term = v0 * np.sin(theta_rad) t_flight = (term + np.sqrt(term**2 + 2*g*h)) / g return v0 * np.cos(theta_rad) * t_flight # Generate plot angles = np.linspace(0, 90, 100) plt.plot(angles, [projectile_range(25, a) for a in angles], label='h=0') plt.plot(angles, [projectile_range(25, a, 5) for a in angles], label='h=5m') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show() 5. Example Calculations Example 1: Finding the Maximum Range If \\(v_0 = 20\\) m/s and \\(h=0\\) , \\[ R = \\frac{20^2 \\sin(2 \\times 45^\\circ)}{9.81} \\approx 40.8 \\text{ m} \\] Example 2: Effect of Launch Height If \\(v_0 = 20\\) m/s and \\(h=5\\) m, Using the general range formula, we get: $$ R \\approx 45.2 \\text{ m} $$ Example 6: Limitations and Extensions 1. Air Resistance Real-world projectiles experience drag force , which opposes motion and is proportional to velocity. The equation of motion with air resistance is: \\[ F_{\\text{drag}} = - k v^2 \\] where \\( k \\) is the drag coefficient. This modifies the projectile\u2019s trajectory and reduces the range. 2. Wind Effects Tailwind increases the range. Headwind reduces the range. Crosswinds alter the projectile\u2019s horizontal trajectory. 3. Uneven Terrain If a projectile lands on a slope or rough ground , the impact location will differ from the idealized case. This requires numerical methods for better predictions. Numerical Approach Instead of using analytical equations, we can solve the motion equations numerically: - Euler\u2019s method or Runge-Kutta methods can approximate the path. - Computational tools help visualize how drag, wind, and terrain impact motion. Next Steps Implement a Python simulation to model projectile motion under real-world conditions. Projectile Motion Simulation with Air Resistance This project simulates projectile motion with air resistance using Python and NumPy. The code was executed in Google Colab , and the generated image is included below. Python Code in Colab ```python import numpy as np import matplotlib.pyplot as plt Function to simulate projectile motion with air resistance def projectile_motion(v0, theta, h=0, wind=0, k=0.1, g=9.81, t_max=10, dt=0.01): theta_rad = np.radians(theta) v0x = v0 * np.cos(theta_rad) + wind # Initial horizontal velocity, including wind effect v0y = v0 * np.sin(theta_rad) # Initial vertical velocity # Initial conditions x, y = 0, h vx, vy = v0x, v0y # Lists to store the trajectory x_vals, y_vals = [x], [y] t = 0 while y >= 0 and t < t_max: # Stop if projectile hits the ground # Calculate air resistance forces fx = -k * vx fy = -k * vy # Update velocities ax = fx # No horizontal acceleration due to gravity (only air resistance) ay = -g + fy # Vertical acceleration due to gravity and air resistance vx += ax * dt vy += ay * dt # Update positions x += vx * dt y += vy * dt # Store the current position x_vals.append(x) y_vals.append(y) t += dt return np.array(x_vals), np.array(y_vals) Parameters v0 = 50 # Initial velocity (m/s) theta = 45 # Launch angle (degrees) h = 0 # Initial height (m) wind = 5 # Wind speed (m/s), positive for tailwind k = 0.05 # Air resistance coefficient t_max = 15 # Max time for simulation Simulate projectile motion with air resistance and wind x_vals, y_vals = projectile_motion(v0, theta, h, wind, k, t_max) Plotting plt.figure(figsize=(10, 6)) plt.plot(x_vals, y_vals, label=\"Projectile Path with Wind and Air Resistance\", color='b') plt.title(f\"Projectile Motion with Air Resistance and Wind\\nInitial Velocity: {v0} m/s, Angle: {theta}\u00b0\", fontsize=14) plt.xlabel(\"Horizontal Distance (m)\", fontsize=12) plt.ylabel(\"Vertical Distance (m)\", fontsize=12) plt.grid(True) plt.legend() plt.xlim(0, max(x_vals) + 10) plt.ylim(0, max(y_vals) + 10) Show plot plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is a fundamental topic in physics that provides insight into motion under the influence of gravity. By analyzing how the range of a projectile depends on its angle of projection, we can explore the underlying principles of kinematics and dynamics. The motion is governed by a set of equations involving parameters such as: - Initial velocity ( \\(v_0\\) ) - Acceleration due to gravity ( \\(g\\) ) - Launch height ( \\(h\\) ) - Launch angle ( \\(\\theta\\) ) These parameters influence the motion in both the horizontal and vertical directions, leading to a wide range of applications, from sports to aerospace engineering.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"The motion of a projectile can be analyzed by splitting it into horizontal and vertical components.","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-kinematic-equations","text":"Horizontal motion (constant velocity): $$ x = v_0 \\cos(\\theta) t $$ Vertical motion (under acceleration due to gravity): $$ y = h + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$","title":"1.1 Kinematic Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time it takes for the projectile to hit the ground ( \\(y=0\\) ) is found by solving: \\[ h + v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 = 0 \\] Solving this quadratic equation for \\(t\\) , we get: \\[ t = \\frac{v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g h}}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-of-the-projectile","text":"The range \\(R\\) is the horizontal distance covered by the projectile: \\[ R = v_0 \\cos(\\theta) \\times t \\] Substituting \\(t\\) from the time of flight equation: \\[ R = \\frac{v_0 \\cos(\\theta) \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2 g h} \\right)}{g} \\] For a projectile launched from ground level ( \\(h=0\\) ), the formula simplifies to: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1.3 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-launch-angle","text":"The range is maximum when \\(\\theta = 45^\\circ\\) in the ideal case ( \\(h=0\\) ). For nonzero initial height, the maximum angle may shift slightly.","title":"2.1 Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-effect-of-other-parameters","text":"Increasing \\(v_0\\) increases the range quadratically. Higher launch heights generally increase the range. Increasing \\(g\\) (e.g., on different planets) decreases the range.","title":"2.2 Effect of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports : Optimizing the angle for maximum distance in long jump, basketball shots, etc. Engineering : Designing artillery, rocket launch trajectories. Astrophysics : Studying trajectories of objects on planetary surfaces.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(v0, theta, h=0, g=9.81): theta_rad = np.deg2rad(theta) term = v0 * np.sin(theta_rad) t_flight = (term + np.sqrt(term**2 + 2*g*h)) / g return v0 * np.cos(theta_rad) * t_flight # Generate plot angles = np.linspace(0, 90, 100) plt.plot(angles, [projectile_range(25, a) for a in angles], label='h=0') plt.plot(angles, [projectile_range(25, a, 5) for a in angles], label='h=5m') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (m)') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-example-calculations","text":"","title":"5. Example Calculations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-1-finding-the-maximum-range","text":"If \\(v_0 = 20\\) m/s and \\(h=0\\) , \\[ R = \\frac{20^2 \\sin(2 \\times 45^\\circ)}{9.81} \\approx 40.8 \\text{ m} \\]","title":"Example 1: Finding the Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-2-effect-of-launch-height","text":"If \\(v_0 = 20\\) m/s and \\(h=5\\) m, Using the general range formula, we get: $$ R \\approx 45.2 \\text{ m} $$","title":"Example 2: Effect of Launch Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#example-6-limitations-and-extensions","text":"","title":"Example 6: Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-air-resistance","text":"Real-world projectiles experience drag force , which opposes motion and is proportional to velocity. The equation of motion with air resistance is: \\[ F_{\\text{drag}} = - k v^2 \\] where \\( k \\) is the drag coefficient. This modifies the projectile\u2019s trajectory and reduces the range.","title":"1. Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-wind-effects","text":"Tailwind increases the range. Headwind reduces the range. Crosswinds alter the projectile\u2019s horizontal trajectory.","title":"2. Wind Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-uneven-terrain","text":"If a projectile lands on a slope or rough ground , the impact location will differ from the idealized case. This requires numerical methods for better predictions.","title":"3. Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#numerical-approach","text":"Instead of using analytical equations, we can solve the motion equations numerically: - Euler\u2019s method or Runge-Kutta methods can approximate the path. - Computational tools help visualize how drag, wind, and terrain impact motion.","title":"Numerical Approach"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#next-steps","text":"Implement a Python simulation to model projectile motion under real-world conditions.","title":"Next Steps"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-simulation-with-air-resistance","text":"This project simulates projectile motion with air resistance using Python and NumPy. The code was executed in Google Colab , and the generated image is included below.","title":"Projectile Motion Simulation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-in-colab","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Code in Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#function-to-simulate-projectile-motion-with-air-resistance","text":"def projectile_motion(v0, theta, h=0, wind=0, k=0.1, g=9.81, t_max=10, dt=0.01): theta_rad = np.radians(theta) v0x = v0 * np.cos(theta_rad) + wind # Initial horizontal velocity, including wind effect v0y = v0 * np.sin(theta_rad) # Initial vertical velocity # Initial conditions x, y = 0, h vx, vy = v0x, v0y # Lists to store the trajectory x_vals, y_vals = [x], [y] t = 0 while y >= 0 and t < t_max: # Stop if projectile hits the ground # Calculate air resistance forces fx = -k * vx fy = -k * vy # Update velocities ax = fx # No horizontal acceleration due to gravity (only air resistance) ay = -g + fy # Vertical acceleration due to gravity and air resistance vx += ax * dt vy += ay * dt # Update positions x += vx * dt y += vy * dt # Store the current position x_vals.append(x) y_vals.append(y) t += dt return np.array(x_vals), np.array(y_vals)","title":"Function to simulate projectile motion with air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameters","text":"v0 = 50 # Initial velocity (m/s) theta = 45 # Launch angle (degrees) h = 0 # Initial height (m) wind = 5 # Wind speed (m/s), positive for tailwind k = 0.05 # Air resistance coefficient t_max = 15 # Max time for simulation","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulate-projectile-motion-with-air-resistance-and-wind","text":"x_vals, y_vals = projectile_motion(v0, theta, h, wind, k, t_max)","title":"Simulate projectile motion with air resistance and wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plotting","text":"plt.figure(figsize=(10, 6)) plt.plot(x_vals, y_vals, label=\"Projectile Path with Wind and Air Resistance\", color='b') plt.title(f\"Projectile Motion with Air Resistance and Wind\\nInitial Velocity: {v0} m/s, Angle: {theta}\u00b0\", fontsize=14) plt.xlabel(\"Horizontal Distance (m)\", fontsize=12) plt.ylabel(\"Vertical Distance (m)\", fontsize=12) plt.grid(True) plt.legend() plt.xlim(0, max(x_vals) + 10) plt.ylim(0, max(y_vals) + 10)","title":"Plotting"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#show-plot","text":"plt.show()","title":"Show plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum Analysis 1. Theoretical Foundation The forced damped pendulum is governed by the following differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency. 1.1 Approximate Solution for Small-Angle Oscillations For small angles, we approximate: \\[ \\sin\\theta \\approx \\theta \\] which simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear nonhomogeneous differential equation. The general solution consists of: - Homogeneous solution (natural response): $$ \\theta_h (t) = C_1 e^{-\\frac{b}{2} t} \\cos \\left( \\omega_0 t + \\phi \\right) $$ where \\(\\omega_0 = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\) is the damped natural frequency. Particular solution (steady-state response): $$ \\theta_p (t) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\cos(\\omega t - \\delta) $$ where \\(\\delta\\) is the phase shift. Thus, the full solution is: \\[ \\theta (t) = \\theta_h (t) + \\theta_p (t) \\] 1.2 Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system. At resonance: \\[ \\omega \\approx \\omega_0 \\] Energy absorption is maximized, leading to large oscillations if damping is small. 2. Analysis of Dynamics 2.1 Influence of System Parameters Damping coefficient \\(b\\) : Higher damping suppresses oscillations and prevents resonance. Driving amplitude \\(A\\) : Larger forcing increases the steady-state oscillation amplitude. Driving frequency \\(\\omega\\) : Controls resonance and possible transition to chaotic motion. -This plot shows how \\(\\theta(t)\\) evolves over time for different parameter values. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega = 2.0 # driving frequency # Define the equation of motion def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 50) y0 = [0.1, 0] # Small initial displacement t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the solution plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Time Evolution of Theta') plt.grid() plt.show() 2.2 Regular vs. Chaotic Motion At low amplitudes, motion remains periodic. However, increasing \\(A\\) and modifying \\(\\omega\\) can lead to chaotic behavior, characterized by sensitivity to initial conditions. Regular omega_values = np.linspace(1.0, 2.5, 50) theta_max = [] for w in omega_values: omega = w sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) theta_max.append(np.max(sol.y[0][-100:])) plt.figure(figsize=(8, 5)) plt.plot(omega_values, theta_max, 'bo', markersize=2) plt.xlabel('Driving Frequency \u03c9') plt.ylabel('Max Theta (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show() # Sample points at the period of the driving force poincare_t = np.arange(0, 50, 2 * np.pi / omega) poincare_theta = np.interp(poincare_t, sol.t, sol.y[0]) poincare_omega = np.interp(poincare_t, sol.t, sol.y[1]) plt.figure(figsize=(8, 5)) plt.scatter(poincare_theta, poincare_omega, s=10, color='r') plt.xlabel('Theta (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show() Chaotic plt.figure(figsize=(8, 5)) plt.plot(sol.y[0], sol.y[1], label='Phase Portrait') plt.xlabel('Theta (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Phase Portrait of the Forced Damped Pendulum') plt.legend() plt.grid() plt.show() 3. Practical Applications Energy harvesting: Extracting vibrational energy for power generation. Suspension bridges: Resonance effects in structural engineering. Oscillating circuits: Analogous to forced RLC circuits in electrical engineering. 4. Computational Implementation We use Python to numerically solve and visualize the forced damped pendulum using the Runge-Kutta method. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega = 2.0 # driving frequency def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 50) y0 = [0.1, 0] # Small initial displacement t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the solution plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid() plt.show() 4.1 Phase Portrait and Poincar\u00e9 Section To visualize transitions to chaos, we plot phase portraits and Poincar\u00e9 sections: plt.plot(sol.y[0], sol.y[1], label='Phase Portrait') plt.xlabel('Theta (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.legend() plt.grid() plt.show() 5. Discussion 5.1 Limitations Small-angle approximation loses accuracy for large oscillations. Real-world damping is often nonlinear. External forcing may not always be purely periodic. 5.2 Extensions Nonlinear damping: Explore air resistance effects. Stochastic forcing: Random perturbations for real-world modeling. 6. Conclusion This study illustrates the rich dynamics of the forced damped pendulum, from simple harmonic motion to chaos. Through theoretical analysis and computational modeling, we gain insight into key factors influencing oscillatory systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-analysis","text":"","title":"Forced Damped Pendulum Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is governed by the following differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-approximate-solution-for-small-angle-oscillations","text":"For small angles, we approximate: \\[ \\sin\\theta \\approx \\theta \\] which simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] This is a linear nonhomogeneous differential equation. The general solution consists of: - Homogeneous solution (natural response): $$ \\theta_h (t) = C_1 e^{-\\frac{b}{2} t} \\cos \\left( \\omega_0 t + \\phi \\right) $$ where \\(\\omega_0 = \\sqrt{\\frac{g}{L} - \\frac{b^2}{4}}\\) is the damped natural frequency. Particular solution (steady-state response): $$ \\theta_p (t) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (b\\omega)^2}} \\cos(\\omega t - \\delta) $$ where \\(\\delta\\) is the phase shift. Thus, the full solution is: \\[ \\theta (t) = \\theta_h (t) + \\theta_p (t) \\]","title":"1.1 Approximate Solution for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system. At resonance: \\[ \\omega \\approx \\omega_0 \\] Energy absorption is maximized, leading to large oscillations if damping is small.","title":"1.2 Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-influence-of-system-parameters","text":"Damping coefficient \\(b\\) : Higher damping suppresses oscillations and prevents resonance. Driving amplitude \\(A\\) : Larger forcing increases the steady-state oscillation amplitude. Driving frequency \\(\\omega\\) : Controls resonance and possible transition to chaotic motion. -This plot shows how \\(\\theta(t)\\) evolves over time for different parameter values. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega = 2.0 # driving frequency # Define the equation of motion def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 50) y0 = [0.1, 0] # Small initial displacement t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the solution plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Time Evolution of Theta') plt.grid() plt.show()","title":"2.1 Influence of System Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-regular-vs-chaotic-motion","text":"At low amplitudes, motion remains periodic. However, increasing \\(A\\) and modifying \\(\\omega\\) can lead to chaotic behavior, characterized by sensitivity to initial conditions.","title":"2.2 Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular","text":"omega_values = np.linspace(1.0, 2.5, 50) theta_max = [] for w in omega_values: omega = w sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) theta_max.append(np.max(sol.y[0][-100:])) plt.figure(figsize=(8, 5)) plt.plot(omega_values, theta_max, 'bo', markersize=2) plt.xlabel('Driving Frequency \u03c9') plt.ylabel('Max Theta (rad)') plt.title('Bifurcation Diagram') plt.grid() plt.show() # Sample points at the period of the driving force poincare_t = np.arange(0, 50, 2 * np.pi / omega) poincare_theta = np.interp(poincare_t, sol.t, sol.y[0]) poincare_omega = np.interp(poincare_t, sol.t, sol.y[1]) plt.figure(figsize=(8, 5)) plt.scatter(poincare_theta, poincare_omega, s=10, color='r') plt.xlabel('Theta (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Poincar\u00e9 Section') plt.grid() plt.show()","title":"Regular"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaotic","text":"plt.figure(figsize=(8, 5)) plt.plot(sol.y[0], sol.y[1], label='Phase Portrait') plt.xlabel('Theta (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.title('Phase Portrait of the Forced Damped Pendulum') plt.legend() plt.grid() plt.show()","title":"Chaotic"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy harvesting: Extracting vibrational energy for power generation. Suspension bridges: Resonance effects in structural engineering. Oscillating circuits: Analogous to forced RLC circuits in electrical engineering.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-computational-implementation","text":"We use Python to numerically solve and visualize the forced damped pendulum using the Runge-Kutta method. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # gravity (m/s^2) L = 1.0 # length of pendulum (m) b = 0.2 # damping coefficient A = 1.2 # driving amplitude omega = 2.0 # driving frequency def pendulum(t, y): theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Time span and initial conditions t_span = (0, 50) y0 = [0.1, 0] # Small initial displacement t_eval = np.linspace(*t_span, 1000) sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot the solution plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Theta (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid() plt.show()","title":"4. Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#41-phase-portrait-and-poincare-section","text":"To visualize transitions to chaos, we plot phase portraits and Poincar\u00e9 sections: plt.plot(sol.y[0], sol.y[1], label='Phase Portrait') plt.xlabel('Theta (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.legend() plt.grid() plt.show()","title":"4.1 Phase Portrait and Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-discussion","text":"","title":"5. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#51-limitations","text":"Small-angle approximation loses accuracy for large oscillations. Real-world damping is often nonlinear. External forcing may not always be purely periodic.","title":"5.1 Limitations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#52-extensions","text":"Nonlinear damping: Explore air resistance effects. Stochastic forcing: Random perturbations for real-world modeling.","title":"5.2 Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-conclusion","text":"This study illustrates the rich dynamics of the forced damped pendulum, from simple harmonic motion to chaos. Through theoretical analysis and computational modeling, we gain insight into key factors influencing oscillatory systems.","title":"6. Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}